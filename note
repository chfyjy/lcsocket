模型
  b/s 浏览器/服务器 
  c/s 客户端/服务器

网络分层模型
  osi
      应用层->表示层->会话层->传输层->网络层->数据链路层->物理层

  tcp/ip
      应用层               ->传输层->网络层->网络接口层
      ftp/http...           tcp协议  ip协议

以太网帧格式 数据长度最大为1500 大数据传输时需分包粘包 或者放弃使用以太网帧

目的地址(6byte) 源地址(6byte) 类型(2byte) 数据(46-1500 byte) crc(4byte)

arp数据报格式 类型 arp 0806  rarp 0835
目的地址(6byte) 源地址(6byte) 类型(2byte) 硬件类型(2byte) 协议类型(2byte) 硬件地址长度(1byte) 协议地址长度(1byte) op(2byte) 发送端以太网地址(6byte) 发送端ip地址(4byte) 接收端以太网地址(6byte) 接收端ip地址(4byte) 填充位(18byte)

arp -a 查看arp缓存的条目 -d 删除

端口对应进程

udp数据报头格式 
  16bit源端口号16bit目的端口号 16bit udp长度值 16bit udp校验和 合8byte
tcp数据报头格式 
  16bit源端口号16bit目的端口号
  32bit序号 32bit确认序号 4bit 首部长度 6bit保留位 6位标志位
  16bit窗口大小 16bit 校验和 16bit 紧急指针 


net 映射
[
通过ARP映射表来观察网络中计算机的MAC地址和IP地址的映射关系，并可选定欲控制的计算机条目进行配置。
arp绑定设置可以防止ARP攻击，因为ARP病毒可以伪IP为代理服务器（但MAC地址还是本机的），如果没有绑定的话，内部局域网的会不停的访问中了ARP病毒的电脑,自然你就上不了网了！
如果绑定了之后，MAC地址和IP地址就一一对应了，防ARP攻击的目的就达到了
]

路由器中存在映射表和路由表 
映射表存储了局域网ip对应的公网ip

打洞

打洞的本质就是利用net的特性“只有当内部主机先给IP地址为X的外部主机发送IP包,该外部主机才能向该内部主机发送IP包”

实现步骤（各个实现可能都不一样）

我们先假设一下：有一个服务器S在公网上有一个IP，两个私网分别由NAT-A和NAT-B连接到公网，NAT-A后面有一台客户端A，NAT-B 后面有一台客户端B，现在，我们需要借助S将A和B建立直接的TCP连接，即由B向A打一个洞，让A可以沿这个洞直接连接到B主机，就好像NAT-B不存在一样。
实现过程如下：
1、 S启动两个网络侦听，一个叫【主连接】侦听，一个叫【协助打洞】的侦听。
2、 A和B分别与S的【主连接】保持联系。
3、 当A需要和B建立直接的TCP连接时，首先连接S的【协助打洞】端口，并发送协助连接申请。同时在该端口号上启动侦听（保证net类型3也能成功）。注意由于要在相同的网络终端上绑定到不同的套接字上，所以必须为这些套接字设置 SO_REUSEADDR 属性（即允许重用），否则侦听会失败。
4、 S的【协助打洞】连接收到A的申请后通过【主连接】通知B，并将A经过NAT-A转换后的公网IP地址和端口等信息告诉B。
5、 B收到S的连接通知后首先与S的【协助打洞】端口连接，随便发送一些数据后立即断开，这样做的目的是让S能知道B经过NAT-B转换后的公网IP和端口号。
6、 B尝试与A的经过NAT-A转换后的公网IP地址和端口进行connect（这就是所谓“打洞”），根据不同的路由器会有不同的结果，有些路由器在这个操作就能建立连接（例如我用的TPLink R402），大多数路由器对于不请自到的SYN请求包直接丢弃而导致connect失败，但NAT-A会纪录此次连接的源地址和端口号，为接下来真正的连接做好了准备，这就是所谓的打洞，即B向A打了一个洞，下次A就能直接连接到B刚才使用的端口号了。
7、 客户端B打洞的同时在相同的端口上启动侦听。B在一切准备就绪以后通过与S的【主连接】回复消息“我已经准备好”，S在收到以后将B经过NAT-B转换后的公网IP和端口号告诉给A。
8、 A收到S回复的B的公网IP和端口号等信息以后，开始连接到B公网IP和端口号，由于在步骤6中B曾经尝试连接过A的公网IP地址和端口，NAT-A纪录 了此次连接的信息，所以当A主动连接B时，NAT-B会认为是合法的SYN数据，并允许通过，从而直接的TCP连接建立起来了。

linux文件类型(7种)
文件
  普通文件 软连接 目录文件 (占存储)
伪文件
  字符设备  块设备 管道(一端读一端写 半双工) 套接字(可同时读写 全双工)

套接字 一个文件描述符+读,写缓冲区

字节序 (大小端)
  大端 低地址对应高位 高地址对应低位
  小端 低地址对应地位 高地址对应高位

  x86采用小端存储 tcp/ip规定通讯为大端

查看端口666的状态 netstat -apn | grep 666

read 返回值n
	正常 n > 0 实际读到的字节数为n
	     n = 0 数据读完
	     n < 0 异常
		errno	EINTR 被信号中断 重启或退出
			EAGAIN/EWOULDBLOCK 非阻塞方式读 并且没有数据读 过段时间再尝试读
			其他  错误



多线程 多进程并发占用的cpu很多 适用于小型的服务 大量数据交互时 则不适用


tcp状态转换 https://blog.csdn.net/wenqian1991/article/details/40110703
	主动 被动 同时操作
半关闭
	shutdown函数

2MSL

端口复用

多路io转接服务器

	select

	poll

	epoll


